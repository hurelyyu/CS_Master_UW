{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red38\green38\blue38;
}
\margl1440\margr1440\vieww12880\viewh5620\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 558 Distributed Yaqun Yu and Xiao Liang\'92s Execute Summary\
\pard\pardeftab720\sl400\partightenfactor0

\f1\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Assignment Overview:
\fs26 \
\pard\pardeftab720\ri-2272\qj\partightenfactor0

\fs28 \cf4 \cb1 \outl0\strokewidth0 The purpose of this project is to use two protocols TCP and UDP to perform three basic client/server functions: put, get and delete. Put function contains two augments key and value, get and delete only need key. The server should always running and it must display the requests it received and the responses by itself. The client will robust to server failure by using a timeout mechanism and should read commands from a script which is our command set will talks about in a while. Every time, the communication between server and client need be record into server log and client log, the request, the reply and the exception (errors). Based on the request, we need also create the makefile for us to build both the server and client code bases into executable binaries, .class format. For the test command set, we will need to 50 distinct GET/PUT/DELETE transactions on key-value pairs, during which we must do at least 10 key-value pairs and at least five of each operation: 5 PUTs, 5 GETs, 5 DELETEs. During the communication, since we are single-thread, we can only execute one command at a time. And TCP can guarantee package delivery, which UDP is more flexible, the sender will not wait to make sure that the recipient will be receiving the package. \
\
Technical Impression:\
During the implementation we create a hashmap class to define our three functions and easy for future recall. And then we generate a log file to record all the informations that we get from our client and server, by define different file path allow us to create different log for server and client seperately. Next, for TCP server, we have the three args[0], args[1] and args[2] to be augments for operation contents, hostname and port number. After create the log file for server, for each request we received, if there is errors during communication, record this into our log, if successfully operated, reply to client with the correct information and then output the key, value or value and also record into our log. For TCP client side, it will send the request and get the output or error from the server side. During the execution of our 50 test set, since TCP need to wait for server reply, it is much slow than UDP protocol. For our UDP protocol, the implementation is pretty similar,  the delivery of our package is not guaranteed but the speed is improved a lot. For our test data we tried a sh method but it so depend on file path, it causes confusion. So we switch to reading command directly from text file. we document our steps in our assignment.   \
During the implementation we have a little bit confuse about the test set at first, but it has been clearified by professor during class. By doing this project helps us understand how TCP and UDP protocol works during real examples and the different between them. \
}